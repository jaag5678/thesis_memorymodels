\section{Approach}

    For addressing the validity of eliminations under our memory model, we separately address first Read elimination, followed by Write elimination, both at the candidate level. 
    We finally address them at the program level with conditionals and loops involved. 

    We consider the same set of assumptions for reordering here. 
    Similar to reordering, our main objective is to ensure that the set of possible observable behaviors of a program, remain unchanged after elimination. 
    In the case of read elimination, we would want the observable behaviors apart from the specific read eliminated to be a subset.
    In the case of write elimination, there is no such constraint as that for reads.
    For both cases, if preserving all behaviors is not possible, then we would want the set of observable behaviors after elimination at the very least to be a subset.
