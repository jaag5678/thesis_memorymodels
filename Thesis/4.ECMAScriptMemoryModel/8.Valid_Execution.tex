%Consistent Executions-------------------------------------------------------------------------------------------------------------------

   %Consistent Executions-------------------------------------------------------------------------------------------------------------------

   \section{Consistent Executions (Valid Observables)}
      
      Consistent executions are those which should ideally be possible if the program is actually run on some hardware. 
      For a sequential program, we use the semantics of the programming language to understand what can be the outcome of a program. 
      For a concurrent program, since we can have multiple outcomes of the same program being executed (keeping all inputs constant), we need a semantic model to rely on. 
      The memory model is in essence just this semantic model for programs using shared memory.
      
      In our language, a consistent execution maps to a valid observable behavior, as this is what the user can actually record as an outcome of the program. 
   
      As per the standard specification, valid observable behaviour is when\footnotemark:
        \begin{enumerate}
           \item No $\stck{_\textit{rf}}$ relation violates the above memory consistency rules.
           \item $\stck{_\textit{hb}}$ is a strict partial order.
        \end{enumerate} 

        \textit{The memory model guarantees that every program must have at least one valid observable behaviour.}

        \footnotetext{There is also some conditions on host-specific events (which we mentioned is not of our main concern) and what is called a chosen read, which is nothing but the reads that the underlying hardware memory model allows. Since we are not concerned with the memory models of different hardware, this restriction on reads is not of our concern.}
    