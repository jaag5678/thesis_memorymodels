%Valid Execution Rules---------------------------------------------------------------------------------------------------------------------------------
        
    \section{Valid Execution Rules (the Axioms)}
        We now state the memory consistency rules. The rules are on \textit{Candidate Executions} which will place constraints on the possible \textit{Observable behaviors} that may result from it. 
         
        %Coherent Reads   
        \paragraph{Coherent Reads} 
        
            There are certain restrictions of what a read event cannot see at different points of execution based on $\stck{_{hb}}$ relation with write events. 

            Consider a read event $e$ and a write event $d$ having at least overlapping ranges:
            \begin{align*}
                \event{e}{R} \ \wedge \ 
                \event{d}{W} \ \wedge \
                (\Re(e) \cap_\Re \Re(d) \neq \phi).
            \end{align*}

            \begin{itemize}
                %Rule #1
                \item A read value cannot come from a write that has happened after it 
                    \[\reln{e}{hb}{d}\ \Rightarrow{}\ \neg \ \reln{e}{rf}{d}.\]
                
                %Rule #2    
                \item A read cannot read a specific byte address value from write if there is a write $g$ that happens between them which modifies the exact byte address. Note that this rule would be on the $rbf$ relation among two events. 
                
                    \[
                        \reln{d}{hb}{e}
                        \ \wedge \ 
                        \reln{d}{hb}{g} \ \wedge \  \reln{g}{hb}{e}
                        \ \Rightarrow{} \
                        \forall x \in (\Re(d) \cap_\Re \Re(g) \cap_\Re \Re(e)), \ \neg \ \reln{e}{rbf}{(d,x)}.
                    \]
                    
            \end{itemize}
         
        \paragraph{Tear-Free Reads} 
            If two tear free writes $d$ and $g$ and a tear free read $e$ all with equal ranges exist, then $e$ can read only from one of them
                
            \begin{align*}
                \et{d}{tf}\ \wedge\ \et{g}{tf} \ \wedge \ \et{e}{tf} 
                  \ \wedge \ 
                  (\Re(d) \!=\! \Re(g) \!=\! \Re(e)) 
                  \ \Rightarrow{} \ 
                      ((\reln{e}{rf}{d}) 
                      \ \wedge \ 
                      (\neg \ \reln{e}{rf}{g})) 
                  \ \vee \  
                      ((\reln{e}{rf}{g}) 
                      \ \wedge \
                      (\neg \ \reln{e}{rf}{d})).
            \end{align*}
                    
            \critic{blue}{To recap a tear-free event cannot be separated into multiple small events that do the same operation. However, considering different hardware architectures, the notion of tear-free need not necessarily mean this. (eg: A 64bit tear-free write to be done in a 32bit system). In a more abstract sense, we need an event to appear 'tear-free'.}    
            
        \paragraph{Sequentially Consistent Atomics} 
            To specifically define how events that are sequentially consistent affects what values a read cannot see, we assume the following memory order among writes $d$ and $g$ and a read $e$ to be the premise for all the rules:  
                \begin{align*}
                    d \stck{_{mo}} g \stck{_{mo}} e.
                \end{align*}
               
            \begin{itemize}
                \item If all three events are of type $sc$ with equal ranges, then $e$ cannot read from $d$
                    
                    \[ 
                        \et{d}{sc}\ \wedge\ \et{g}{sc}\ \wedge\ \et{e}{sc} 
                        \ \wedge \ (\Re(d) \!=\! \Re(g) \!=\! \Re(e))
                        \ \Rightarrow{} \ 
                        \neg \ \reln{e}{rf}{d}.
                    \]
                    
                \item If both writes are of type $sc$ having equal ranges and the read is bound to happen after them, then $e$ cannot read from $d$ 
                
                    \[
                        \et{d}{sc}\ \wedge\ \et{g}{sc}  
                        \ \wedge \ (\Re(d) \!=\! \Re(g)) 
                        \ \wedge \ \reln{d}{hb}{e}
                        \ \wedge \ \reln{g}{hb}{e}
                        \ \Rightarrow{}\  
                        \neg \ \reln{e}{rf}{d}.
                    \]
                
                \item If $g$ and $e$ are sequentially consistent, having equal ranges, and $d$ is bound to happen before them, then $e$ cannot read from $d$
                
                    \[
                        \et{g}{sc}\ \wedge\ \et{e}{sc}  
                        \ \wedge \ (\Re(g) \!= \!\Re(e)) 
                        \ \wedge \ \reln{d}{hb}{g} 
                        \ \wedge \ \reln{d}{hb}{e}
                        \ \Rightarrow \ 
                        \neg \ \reln{e}{rf}{d}.
                    \]
            \end{itemize}
            
            \critic{red}{The standard specification talks of this in terms of what sequentially consistent write $g$ should not be there when an $\stck{_{rf}}$ relation exists among two events. We however, describe it in terms of disallowed $\stck{_{rf}}$ relation to keep the rules consistent} 
        
            \critic{red}{We think we do not necessarily need ranges to be equal in some cases, however, this needs to be looked into more carefully. }
            
            
            \critic{blue}{Write events that are sequentially consistent are observed to happen in the same memory order by every agent. This is without any specific $\stck{_{hb}}$ relation among such events. Does this really hold ? This needs to be discussed separately.} 
        
