     
    
      
    For this reason, weaker consistency models have been introduced to concurrent, shared-memory languages (both high and low level) to leverage more of the \textit{out-of-order} execution notion. 
    For instance, under the ECMAScript consistency model semantics, if all the accesses are of type \textit{unordered}, the above invalid outcome is allowed, which implies a reordering of such events is valid in the above case. 
    The problem, however, is that semantics of such weak consistency can be easily misunderstood, and is often defined in informal prose format, thus leading to misinterpretation of intended semantics, which leads to several issues. 
    Other problems that exist is incorrect compilation, which causes programs to misbehave when executed on different hardware / target lanaguegs. 
    It has also been shown that verification of such programs is much difficult to do due to more state space explosions.
    For our purpose, it makes it difficult to assert when a particular program transformation is valid / safe. 
    
    Our focus, therefore, in this thesis is to first offer a clarified, more concise rendition of the core ECMAScript memory model that allows for better abstract reasoning over allowed and disallowed behaviours (outcomes). 
    We use our model to provide a straightforward, conservative proof of when reordering of independent instructions and elimination is permitted, addressing optimization in terms of its impact on observable program behaviours. 
    Specific contributions of our work include the following:
    
    \begin{enumerate}
        \item We provide a concise \textit{declarative(axiomatic) style} model of the core ECMAScript memory consistency semantics. This clarifies the existing draft presentation~\cite{ECMA} in a manner useful for validating optimizations.
        \item Using this model, we show when basic reordering of independent instructions is allowed. We extend this to reordering in the presence of conditionals and loops in programs.
        \item Similar proof designs are used to validate other basic optimization behaviours such as removing redundant reads or writes. Further extending it to elimination in the presence of conditionals and loops. 
        \item We lastly show how our above two results help us check the validity of loop invariant code motion. 
    \end{enumerate}
  