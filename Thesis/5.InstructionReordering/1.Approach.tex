\section{Summary of Our Approach}

    An example-based analysis exposes to us the problems that might exist when we perform such reordering of events. 
    However, such an analysis, though would work for small programs to identify the possible conditions under which reordering can be done, become infeasible as the programs scale in length and complexity. 
    This is because of the exponential increase in possible executions as the number of threads and program size in general increase. 
    Hence,  generalizations by using a small sample size is not something we can afford especially when we want to ensure these program trasnformations are done by the compiler in contrast to being done manually.
    
    Our solution to this is to construct a proof on Candidate Executions of the original program and the transformed one which exposes the possible observable behaviors it can have.   
    The crux of the proof is to guarantee that reordering does not bring any new $\stck{_{rf}}$ (reads-from) relations that did not exist in any Observable Behavior of the original Candidate Execution. 
    It is important to note however, that a proof in this sense would be generalized to any Candidate and is thus conservative.
    So, it might be the case that for specific programs, reordering can be valid, however, in a general sense may not be valid for others. 

    \paragraph{Assumption}
    We make the following assumptions for every program we consider :
    \begin{enumerate}
        \item All events are tear-free
        \item No synchronize events exist
        \item No Read-Modify-Write events exist
        \item All executions of the candidate before reordering have happens-before as a strict partial order
    \end{enumerate}
    
    We first consider when consecutive events in the same agent can be reordered, followed by non-consecutive cases. The crux of the proof is to guarantee that reordering does not bring any new reads-from relations that did not result due to any execution of the original program. 

    We view reordering as manipulating the agent-order relation. In that sense, reordering two consecutive events $e$ and $d$ such that $e \stck{_{ao}} d$ becomes:
    \[
        e \stck{_{ao}} d 
        \longmapsto
        d \stck{_{ao}} e 
    \]

    What implications this change has on the other ordering relations depends on the type of events $e$ and $d$ are and would require an analysis on each Candidate Execution. 
    The intuition is that the axioms of the memory model rely on certain ordering relations to restrict observable behaviors in a program.
    Hence, preserving these ordering relations would help us in turn not introduce new Observable Behaviors.
    In particular we note that preserving $\stck{_{hb}}$ relations (other than the one we eliminate intentionally i.e $\reln{e}{hb}{d}$) would suffice for our purpose. 
    Since $\stck{_{mo}}$ respects $\stck{_{hb}}$, we in turn even preserve the memory order which is essential.  
    
    
    \critic{purple}{The following definitions and lemmas are not particular to instruction reordering, so I think we can make it a point to put this in a section that introduces our work on optimizations.}

