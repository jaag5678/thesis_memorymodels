\boolfalse {citerequest}\boolfalse {citetracker}\boolfalse {pagetracker}\boolfalse {backtracker}\relax 
\defcounter {refsection}{0}\relax 
\contentsline {chapter}{\numberline {1}Introduction}{1}
\defcounter {refsection}{0}\relax 
\contentsline {chapter}{\numberline {2}Background}{4}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {2.1}Memory Consistency Models}{4}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{x86}{6}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Java}{6}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{C++/C11}{6}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Mixed-size models}{7}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {2.2}Program Transformations under Weak Memory}{7}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {2.3}Axiomatic Style Specifications of Weak Memory}{11}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {2.4}Other Concerns}{11}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Compilation}{11}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Verificaiton / Model Checking}{12}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Out of Thin Air }{12}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Custom Memory Models}{12}
\defcounter {refsection}{0}\relax 
\contentsline {chapter}{\numberline {3}The Memory Model}{14}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{The Model is Quite Algorithmic}{14}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Certain Unnecessary Definitions}{16}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Still a bit verbose}{17}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {3.1}Agents, Events and their Types}{18}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Agents}{18}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Agent Cluster}{18}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Agent Event List $(ael)$}{18}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {3.2}Events}{18}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.2.1}Event Types}{18}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.2.2}Range ($\Re $)}{19}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.2.3}Event Order / Event Access Mode}{20}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.2.4}Tear Free ($tf$) or Tearing $!tf$)}{21}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {3.3}Relation among events}{21}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.3.1}Read-Write event relations}{22}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Read-Bytes-From $(\mathrel {\mathop {_{rbf}}\limits ^{\DOTSB \relbar \joinrel \rightarrow }})$}{22}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Reads-From $(\mathrel {\mathop {_{rf}}\limits ^{\DOTSB \relbar \joinrel \rightarrow }})$}{22}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.3.2}Agent-Synchronizes With (\textbf {\textit {ASW}})}{22}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {3.4}Ordering Relations among Events}{23}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.4.1}Agent Order ($\mathrel {\mathop {_{ao}}\limits ^{\DOTSB \relbar \joinrel \rightarrow }}$)}{23}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.4.2}Synchronize-With Order ($\mathrel {\mathop {_{sw}}\limits ^{\DOTSB \relbar \joinrel \rightarrow }} $)}{24}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.4.3}Happens Before Order ($\mathrel {\mathop {_{hb}}\limits ^{\DOTSB \relbar \joinrel \rightarrow }}$)}{24}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.4.4}Memory Order ($\mathrel {\mathop {_{mo}}\limits ^{\DOTSB \relbar \joinrel \rightarrow }}$)}{25}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {3.5}Helper Definitions}{26}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {3.6}Valid Execution Rules (the Axioms)}{27}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {3.7}Race}{30}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.7.1}Race Condition $RC$}{30}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {3.7.2}Data Race $DR$}{31}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Data-Race-Free (DRF) Programs}{31}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {3.8}Consistent Executions (Valid Observables)}{31}
\defcounter {refsection}{0}\relax 
\contentsline {chapter}{\numberline {4}Instruction Reordering}{33}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {4.1}Introduction}{33}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Simple reordering is not straightforward under shared memory semantics}{34}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Some Examples}{34}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {4.2}Summary of Our Approach}{36}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Assumption}{36}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {4.3}Some Useful Definitions}{37}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {4.4}Useful Lemmas}{38}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {4.5}Valid reordering at the Candidate Level}{41}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {4.5.1}Reordering of Consecutive Events}{42}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{1. Preserving \textit {happens-before} relations}{42}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{2. Additional \textit {happens-before} relations}{47}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{3. Presence of cycles?}{48}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{4. Do new relations introduce new observable behaviors?}{51}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {4.5.2}Reordering Non-Consecutive Events}{56}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Base Case: $n = 1.$}{57}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{2. Inductive Case $n > 1$}{58}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {4.5.3}Counter Examples for all the Invalid Cases}{59}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Reads to same memory where $e$ is of type $sc$ while $d$ is of either $uo/sc$}{59}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{A Read $e$ of type $sc$ followed by a Write of either $uo/sc$}{61}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{A Read $e$ of type $uo$ followed by a write $d$ of type $sc$}{63}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{A Write $e$ followed by a Read $d$ both of type $sc$}{63}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{A Write $e$ of type $uo/sc$ followed by a Write $d$ of type $sc$}{64}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {4.6}From Candidates to Program}{65}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {4.6.1}Addressing programs with Conditionals}{66}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {4.6.2}Counter Examples for Programs with Conditionals}{70}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {4.6.3}Addressing Programs with Loops}{75}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Reordering Accross Loops}{76}
\defcounter {refsection}{0}\relax 
\contentsline {chapter}{\numberline {5}Elimination}{77}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {5.1}Elimination}{77}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{1. Preserving \emph {happens-before} relations}{80}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{2. The \emph {happens-before} relations lost}{80}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{3. Presence of Cycles?}{81}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{4. Do the lost relations result in New Observable Behaviors?}{81}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Preserving Happens-before relations}{83}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{2. The \emph {happens-before} relations lost}{83}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{3. Presence of Cycles?}{83}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{4. Do the lost relations result in New Observable Behaviors?}{83}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Base Case : n = 1}{86}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Inductive Case (n)}{86}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {5.2}From Candidates to Program}{87}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {5.2.1}Addressing Programs with Conditionals}{87}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {5.2.2}Addressing Programs with Loops}{89}
\defcounter {refsection}{0}\relax 
\contentsline {subsubsection}{Loop Invariant Code motion}{90}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Reordering two events accross loops}{97}
\defcounter {refsection}{0}\relax 
\contentsline {chapter}{\numberline {6}Conclusion, Summary, Future Work}{99}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {6.1}Limitations/Advantages}{99}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Separation of Concerns}{99}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Validity of Transformations is a conservative}{100}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Lack of Practical Results}{100}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Mapping from Programming Constructs to Abstract events}{101}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {6.2}Steps Further}{101}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Addressing Read-Modify-Write}{101}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Incorporating Tearing Factor}{101}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Role of synchronize/host-specific events}{101}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Addressing other basic program transformations}{102}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {6.3}Critique of the Model itself}{102}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {6.3.1}Tearing Factor and the Tear-free reads Axiom}{102}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {6.3.2}Range of Initialize events uncertain}{103}
\defcounter {refsection}{0}\relax 
\contentsline {subsection}{\numberline {6.3.3}Mixed-size events do not respect Coherence irrespective of access mode}{104}
\defcounter {refsection}{0}\relax 
\contentsline {section}{\numberline {6.4}Future Directions in Weak Memory Consistency}{105}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Specification of Mixed-Size memory models}{105}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Transformational Specification of Memory Models}{106}
\defcounter {refsection}{0}\relax 
\contentsline {paragraph}{Automation of Specification of Weak Memory Models}{106}
