\section{From Candidates to Program}

    \begin{corollary}
        Consider a program $P$ and its candidates $C_1, C_2, ... , C_n$ in which events $e$ and $d$ present such that 
        \begin{align*}
            \event{e}{W} \ \wedge \ \event{d}{W} \ \wedge \ \et{e}{uo} \ \wedge \ \reln{e}{ao}{d} \ \wedge \ \Re(e)\!=\!\Re(d)
        \end{align*} . 
        Consider the set of corresponding candidates $C'_1, C'_2, ... , C'_n$ after eliminating $e$ and its corresponding program $P'$. If
        \begin{align*}
            \forall C_{i \in [1,n]}, \forall k \in C_i \ \text{s.t.} \ \reln{e}{ao}{k} \wedge \reln{k}{ao}{d}, \    
            Reord(e,k)  
        \end{align*}
        and
        \begin{align*}
            \nexists C \in P \ \text{s.t.} \ \event{e}{C} \wedge d \notin C
        \end{align*}
        Then the set of observable behaviors of $P'$ is a subset of that of $P$.
    \end{corollary}

    \begin{proof}
        We first prove that the second condition must hold. We show this by proving that if it does not hold, a new observable behavior can be introduced. 
        
        Suppose the second condition does not hold, then we have 
        \begin{align*}
            \exists C \in P \ \text{s.t.} \  \event{e}{C} \wedge d \notin C
        \end{align*}

        By Prop \ref{CondB1} and Prop \ref{CondB1}, we can infer that the above holds if $e$ or $d$ are part of a conditional branch. 
        \begin{itemize}
            \item Case 1: $e$ and $d$ both are part of conditionals 
                By Prop \ref{CondB2} and \ref{CondB1}, we have 
                \begin{align*}
                    \exists C \in P \ \text{s.t.} \ d \notin C \\ 
                    \exists C \in P \ \text{s.t.} \ e \notin C 
                \end{align*}
                After elimination $e$, we can have a new observable behavior in a candidate not having $d$ as above condition states. 
                
                \critic{red}{Need to refer to part of elimination proof as Coherent Reads would not be triggered anymore for a case and thus we can have a new observable behavior. How to explain this, ask Clark.}

            \item Case 2: $e$ is part of conditional but $d$ is not
                By Prop \ref{CondB2} and \ref{CondB1}, we have 
                \begin{align*}
                    \exists C \in P \ \text{s.t.} \ e \notin C 
                \end{align*}
                After elimination $e$, we cannot have a new observable behavior in a candidate due to not having $d$ as above condition states.

            \item Case 3: $d$ is part of a conditional but $e$ is not 

                By Prop \ref{CondB2} and \ref{CondB1}, we have 
                \begin{align*}
                    \exists C \in P \ \text{s.t.} \ d \notin C
                \end{align*}
                After elimination $e$, we can have a new observable behavior in a candidate not having $d$ as above condition states. 

                \critic{red}{Need to refer to part of elimination proof as Coherent Reads would not be triggered anymore for a case and thus we can have a new observable behavior. How to explain this, ask Clark.}

                \critic{purple}{Add the above property to conditionals with two branches also.}
                
        \end{itemize}

        Now that we have that the second condition must hold, we prove the first condition too must hold. Let $C_i$ and $C_i'$ be the candidates before and after eliminating $e$. From the first condition we have then for $C_i$
        \begin{align*}
            \forall \ k \ \textit{s.t.} \ 
            \reln{e}{ao}{k} \ \wedge \ \reln{k}{ao}{d} \ . \ 
            Reord(e,k).
        \end{align*}
        The above is Corollary 1 (tag properly) for elimination, thus giving us that the observable behaviors of $C_i'$ is a subset of $C_i$. Hence this condition must hold for all candidates from which we eliminate $e$. 

        By property of unions of sets, we can conclude that the set of Observable Behaviors of $P'$ is a subset of that of $P$.

        Hence proved.

        \critic{purple}{We have not given properly the link between Observable Behaviors, Candidate Executions, Candidates and Programs. Perhaps we need to define a function Obs that gives us the set of Observable Behaviors, where the Domain can be a Program, Candidate, or Candidate Execution.}
    \end{proof}

    As far as read elimination goes, since we only need the information of read event that is to be eliminated, we do not need to take cases as above for write elimination. Except there can exist one case, in which the read itself is the conditional check, which can result in choosing any branch based on the conditional being satisfied or not. 
    
    The compiler can ideally choose to eliminate the read event, if the choice of branch has not effect on the execution of the thread. However, the events in each branch can affect the execution of other threads and thus have a role in the possible observable behaviors. But if all the events in each branch are eliminable, then we can safely assume that it does not matter which branch is taken, as although the set of observable behaviors would be different, they would result in the same candidate after events in the chosen branch are eliminated. THis is what we assume the compiler intends to do by eliminating the conditional. 

    \critic{blue}{Explain this a little better.}

    \begin{corollary}
        If the read to be eliminated is a conditional, then only if all events within the conditional can be eliminated, will this be safe to do. 
        \critic{red}{The problem is that this is recursive, and hence the proof must also have some sort of recursion. But to be frank, the proof would not have any assumption on the structure  of flow of code  within each conditional branch, just that we can eliminate some event and what does that imply in terms of observable behaviors.}
        
        \critic{blue}{In order to show we can eliminate a write, we would need some other write po after and that respects the corollary before this one. Perhaps mention that the compiler needs to do a flow analysis to get this done. And this is not that arduous a task in terms of algorithmic complexity.}
    \end{corollary}

    \begin{proof}

        By thoerem of reordering, we can only eliminate the read when it is of type unordered. 

        To prove the next part, consider two candidates $C_1$ and $C_2$, one for each branch taken. Our task is to show that the observable behavior of both these candidates should be the same after the removal of read, which in our terms means the removal of each branch. 

        \critic{blue}{But is it so? The compiler can choose to elimiate the conditional because it always turns out to be only true or only false.}

        \critic{purple}{If it is a write, then we need to have some other write program ordered ahead to show that we can eliminate it. Perhaps put this as a general conditioon and write a boolean funciton to state when a write is eliminable. }

        \critic{purple}{If it is a read, then we only require it to have access mode unordered.}

        \critic{blue}{Perhaps we indeed need more information as to why the compiler is eliminating the conditional check.}

        \begin{itemize}
            \item The read removed is the shared memory one.
            \item Even if the read is of type unordered, removing it will make the branch choice uncertain.
            \item If the compiler thinks that only one branch will always be taken, then it could safely eliminate. 
            \item But we place no assumption on why the compiler is doing so, hence in our eyes, the choice of branch is uncertain.
            \item Given that the compiler does do it with the assurance that the conditional check is futile, one may elimiate the read. 
            \item Perhaps a proof by counter example would suffice to show whether it is safe to do so. 
            \item One best way is to observe that all events that are supposed to happen in each conditional branch, happens nevertheless after the branches merge. So one might want to eliminate events. 
            \item To do the above, the compiler must assure that it can eliminate all events in each branch. If it can do so, then elimianting the read will be safe.
            \item The above can be shown to hold as it is a simple argument based on Observable Behaviors, union of sets and transitive property of subsets. 
            \item However, the question remains as to whether the compiler thinks the shared memory conditional check read is alwys the same value or whether it considers the branch choice irrelevant for the thread. 
            \item If we say that we can eliminate all events in each branch, it shows that these events may not be needed. But if cannot eliminate all events in the branches, it may not imply that it is still safe to eliminate. Discuss with Clark.
        \end{itemize}
    \end{proof}