\section{From Candidates to Program}

    We first consider the elimination of write in programs with conditional branches. We can summarize the cases that result due to such condtionals into the following parts:

    %Put figure here of the cases.

    We do not need to know why the compiler is choosing the eliminate a particular write; we only need to assert that whether it is possible given our conservative analysis on observable behaviors. The following corollary states when doing such an elimination is safe: 

    \begin{corollary}
        Consider a program $P$ and its candidates $C_1, C_2, ... , C_n$ in which events $e$ and $d$ present such that 
        \begin{align*}
            \event{e}{W} \ \wedge \ \event{d}{W} \ \wedge \ \et{e}{uo} \ \wedge \ \reln{e}{ao}{d} \ \wedge \ \Re(e)\!=\!\Re(d)
        \end{align*} . 
        Consider the set of corresponding candidates $C'_1, C'_2, ... , C'_n$ after eliminating $e$ and its corresponding program $P'$. If
        \begin{align*}
            \forall C_{i \in [1,n]}, \forall k \in C_i \ \text{s.t.} \ \reln{e}{ao}{k} \wedge \reln{k}{ao}{d}, \    
            Reord(e,k)  
        \end{align*}
        and
        \begin{align*}
            \nexists C \in P \ \text{s.t.} \ \event{e}{C} \wedge d \notin C
        \end{align*}
        Then the set of observable behaviors of $P'$ is a subset of that of $P$.
    \end{corollary}

    \begin{proof}
        We first prove that the second condition must hold. We show this by proving that if it does not hold, a new observable behavior can be introduced. 
        
        Suppose the second condition does not hold, then we have 
        \begin{align*}
            \exists C \in P \ \text{s.t.} \  \event{e}{C} \wedge d \notin C
        \end{align*}

        By Prop \ref{CondB1} and Prop \ref{CondB1}, we can infer that the above holds if $e$ or $d$ are part of a conditional branch. 
        \begin{itemize}
            \item Case 1: $e$ and $d$ both are part of conditionals 
                By Prop \ref{CondB2} and \ref{CondB1}, we have 
                \begin{align*}
                    \exists C \in P \ \text{s.t.} \ d \notin C \\ 
                    \exists C \in P \ \text{s.t.} \ e \notin C 
                \end{align*}
                After elimination $e$, we can have a new observable behavior in a candidate not having $d$ as above condition states. 
                
                \critic{red}{Need to refer to part of elimination proof as Coherent Reads would not be triggered anymore for a case and thus we can have a new observable behavior. How to explain this, ask Clark.}

            \item Case 2: $e$ is part of conditional but $d$ is not
                By Prop \ref{CondB2} and \ref{CondB1}, we have 
                \begin{align*}
                    \exists C \in P \ \text{s.t.} \ e \notin C 
                \end{align*}
                After elimination $e$, we cannot have a new observable behavior in a candidate due to not having $d$ as above condition states.

            \item Case 3: $d$ is part of a conditional but $e$ is not 

                By Prop \ref{CondB2} and \ref{CondB1}, we have 
                \begin{align*}
                    \exists C \in P \ \text{s.t.} \ d \notin C
                \end{align*}
                After elimination $e$, we can have a new observable behavior in a candidate not having $d$ as above condition states. 

                \critic{red}{Need to refer to part of elimination proof as Coherent Reads would not be triggered anymore for a case and thus we can have a new observable behavior. How to explain this, ask Clark.}

                \critic{purple}{Add the above property to conditionals with two branches also.}
                
        \end{itemize}

        Now that we have that the second condition must hold, we prove the first condition too must hold. Let $C_i$ and $C_i'$ be the candidates before and after eliminating $e$. From the first condition we have then for $C_i$
        \begin{align*}
            \forall \ k \ \textit{s.t.} \ 
            \reln{e}{ao}{k} \ \wedge \ \reln{k}{ao}{d} \ . \ 
            Reord(e,k).
        \end{align*}
        The above is Corollary 1 (tag properly) for elimination, thus giving us that the observable behaviors of $C_i'$ is a subset of $C_i$. Hence this condition must hold for all candidates from which we eliminate $e$. 

        By property of unions of sets, we can conclude that the set of Observable Behaviors of $P'$ is a subset of that of $P$.

        Hence proved.

        \critic{purple}{We have not given properly the link between Observable Behaviors, Candidate Executions, Candidates and Programs. Perhaps we need to define a function Obs that gives us the set of Observable Behaviors, where the Domain can be a Program, Candidate, or Candidate Execution.}
    \end{proof}

    As far as read elimination goes, since we only need the information of read event that is to be eliminated, we do not need to take cases as above for write elimination. Except there can exist one case, in which the read itself is the conditional check. But what is the resultant code after elimination relies on the intention of the compiler, which can be the following:
    \begin{itemize}
        \item It could be plain dead code elimination, wherein both brnaches of code are eliminated entirely. 
        \item It could also be that the conditonal check always returns the same value, which makes the branch taken to be the same. 
        \item It could also be that the choice of branch does not affect the outcome of the program itself. 
    \end{itemize}
    
    Since we aren't certain of the reason, it is difficult to identify the target code that is inteneded after such an elminiation. Hence we do not address this case. It is also not within the scope of our analysis to conhsder the actual mapping between program and candidates. We would need this to prove that the program does not take a particular conditonal branch in any execution. This is not easy to do without the mapping in our hands. 