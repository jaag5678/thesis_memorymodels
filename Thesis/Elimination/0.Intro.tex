\section{Elimination}

    Many programs which contain loops or are representing big softwares fall victim to having many redundant code. 
    This could also be possible due to differnt phases of optimization the compiler performs, which leaves certain residual code in each phase.
    One such example of redundant code is that when there are two consecutive reads or writes writing the same value to the same memory location.
    Another example could be the case that after many optimization passes, certain memory values are not used by the program itself, so the compiler may decide to remove it.  
    In a sequential setting the effect of removing such code is nothing.
    However, as we saw for simple reordering too, in a concurrent setting, elimination may not be that straightforward. 
    
    Let us for instance consider a program where we have two consecutive writes to the same memory writing the same value and the program after eliminating the latter write as below. 

    %SHow example here 

    
    The orange box shows the possible outcome that we want to consider. 
    In the first program, such an outcome should not be allowed. 
    While in the program after eliminating the latter write, this outcome is allowed.
    The following figure explains the relations formed in a candidate execution that can justify the observable behavior in question. 
    
    %Show relations here relevant

    The first set of relations is for the original program, where Axiom \ref{CoRe} prohibits the read $a$ to have value of $y$ as $2$.
    The second set is for the modified program, where none of the axioms.
    
    %For reads
    %I still do not have a counter example to show that elimination of reads is not safe. 
    %This is because I do not yet understand the implications of this on observable behaviors. 
    %Typically, if we remove the read from the set of observables, nothing should change, that is, restrictions on events agent ordered before or after the read must remain as it is.
    %This is because removal of restrictions might lead to new observable behaviors. 
    %The only case where this is not okay is when the read is part of a loop conditional. 
    %Removing such reads from every candidate will resort to non-termination of code.
    %One can jot this down to just restricting elimination of reads that are part of conditionals.
    %But otherwise, one can still eliminate. 
    %I am not sure which other case can be taken. How about showing when two reads are memory ordered without happens-before? Then elimination will not have any use.
    %We can skip this part for now and just refine the previous chapter first.
    An example where reads is unsafe to be eliminated is not quite easy to construct.
    This is because the semantics of the model does not really have any read-read dependance; one read value does not affect any subsequent(agent ordered) read value to same memory unless constrained by happens-before.
    So one might assume that we can freely eliminate reads: this however would not be safe to do, due to other reasons such as forward progress.
    If for instance, a loop repeatedly checks the value of some memory (say $x$) and will terminate only if the memory reads some fixed value, each candidate execution representing each iteration of the loop would represent also the minimum iterations before the read is of fixed value. 
    And this value would be of the read in the last iteration. 
    

    There are two types of elimination we are concerned with:
    \begin{itemize}
        \item Read Elimination
        \item Write Elimination
    \end{itemize}

    We address each part separately.
