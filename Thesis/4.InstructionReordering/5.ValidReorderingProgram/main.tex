\section{From Candidates to Program}

    So far we have only addressed reordering at the Candidate level. 
    In practice, a program can have many Candidates. 
    This is due to the program having several conditional branches and loops. 
    To analyze when we can reorder two events at the program level, we must also address the involvement of conditionals and loops that may be between these two events.
    But locally asserting why a particular reordering is valid is non-trivial to understand. 
    The compiler does global level optimizations that involve several local transformations such as reordering. 
    In addition, the previous proofs show us that we mainly are involved in identifying whether a reordering introduces new observables, not about why such a reordering would be effective for performance.

    Hence, the way we approach this is to not have any assumptions as to why the compiler chooses to do a particular reordering. 
    Instead, we only check if the reordered program can have its observable behaviors as a subset of the original. 
    This ensures that we do not concern ourselves with the algorithm behind the compiler optimization. 
    Such an approach makes reordering parametric to the memory model. 
    The downside is that this approach will be conservative as we use no information as to why a particular set of events are reordered. 
    We do not compare and contrast in details the perks of both approaches. 
    This is beyond the scope of this thesis.
    
    \input{4.InstructionReordering/5.ValidReorderingProgram/conditionals.tex}

    \input{4.InstructionReordering/5.ValidReorderingProgram/counter_examples.tex}

    \input{4.InstructionReordering/5.ValidReorderingProgram/loops.tex}