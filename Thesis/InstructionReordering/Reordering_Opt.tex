
\section{Instruction Reordering}
    Instruction reordering is a common operation in compiler optimization, essential to instruction scheduling of course, but also implicit in loop invariant removal, partial redundancy elimination, and other optimizations that may move instructions. 
    However, whether we can do such reordering freely given a concurrent program using relaxed memory accesses is a bit unclear. 
     
    
    \paragraph{Simple reordering is not straightforward under shared memory semantics}
    The main reason is that memory accesses here, do not just perform the desired operation (i.e Read / Write) but also imply certain visibility guarantees across all the other threads.  
    In our observation, we find that, the relaxed memory model of Javascript prescribe semantics for visibility using the $\stck{_{hb}}$ relations. 
    
    \critic{purple}{Show an example or multiple examples here that enforces visibility due to having sequentially consistent events involved in a Candidate Execution.}
    
    \paragraph{What can be done?}
    An example-based analysis exposes to us the problems that might exist when we perform such reordering of events. 
    However, such an analysis, though would work for small programs to identify the possible conditions under which reordering can be done, become infeasible as the programs scale in length and complexity. 
    This is because of the exponential increase in possible executions as the number of threads and program size in general increase. 
    Hence,  generalizations by using a small sample size is not something we can afford especially when we want to ensure these program trasnformations are done by the compiler in contrast to being done manually.
    
    \paragraph{Our approach}
    Our solution to this is to construct a proof on Candidate Executions of the original program and the transformed one which exposes the possible observable behaviors it can have.   
    The crux of the proof is to guarantee that reordering does not bring any new $\stck{_{rf}}$ (reads-from) relations that did not exist in any Observable Behavior of the original Candidate Execution. 
    It is important to note however, that a proof in this sense would be generalized to any Candidate and is thus conservative.
    So, it might be the case that for specific programs, reordering can be valid, however, in a general sense may not be valid for others. 

    \paragraph{Assumption}
    We make the following assumptions for every program we consider :
    \begin{enumerate}
        \item All events are tear-free
        \item No synchronize events exist
        \item No Read-Modify-Write events exist
        \item All executions of the candidate before reordering have happens-before as a strict partial order
    \end{enumerate}
    
    We first consider when consecutive events in the same agent can be reordered, followed by non-consecutive cases. The crux of the proof is to guarantee that reordering does not bring any new reads-from relations that did not result due to any execution of the original program. 
    
    %GIVE TWO EXAMPLES TO SHOW THIS. POSSIBLY USE THE EXAMPLE ABOVE AND EXPLAIN

    \critic{purple}{The following definitions and lemmas are not particular to instruction reordering, so I think we can make it a point to put this in a section that introduces our work on optimizations.}

    \input{InstructionReordering/definitions.tex}

    \input{InstructionReordering/Lemmas/lemmas.tex}

\subsection{Valid reordering}
    We view reordering as manipulating the agent-order relation among two events. In that sense, reordering two consecutive events $e$ and $d$ such that $e \stck{_{ao}} d$ becomes:
    \[
        e \stck{_{ao}} d 
        \longmapsto
        d \stck{_{ao}} e 
    \]

    What implications this change has on the other ordering relations depends on the type of events $e$ and $d$ are and would require an analysis on each Candidate Execution. 
    The intuition is that the axioms of the memory model rely on certain ordering relations to restrict observable behaviors in a program.
    Hence, preserving these ordering relations would help us in turn not introduce new Observable Behaviors.
    In particular we note that preserving $\stck{_{hb}}$ relations (other than the one we eliminate intentionally i.e $\reln{e}{hb}{d}$) would suffice for our purpose. 
    Since $\stck{_{mo}}$ respects $\stck{_{hb}}$, we in turn even preserve the memory order which is essential.  

    In the end, we want to ensure that the set of possible observable behaviors of a program, remain unchanged after reordering. If that is not feasible, then we would want the set of observable behaviors after reordering at the very least to be a subset. This would ensure that the program does not have some new behaviours that weren't supposed to happen prior to reordering. 
    
    We begin by first defining a reorderable pair of events. We then formulate a theorem (with a proof) on the set of observable behaviors of a Candidate before and after reordering a pair of consecutive events which are reorderable. We consider reordering valid if the set of observable behaviours after reordering are a subset of the original. 

    \begin{definition}{Reorderable Pair (Reord)}
        We define a boolean function \emph{Reord} that takes two ordered pair of events $e$ and $d$ such that $\reln{e}{ao}{d}$ and gives a boolean value indicating if they are a reorderable pair. 
        
        \begin{align*}
            Reord(e,d) = \\
            (
            &((\et{e}{uo} \ \wedge \ \et{d}{uo}) \ \wedge \ 
                    (   
                        (\event{e}{R} \ \wedge \ \event{d}{R}) \ \vee \ 
                        (\Re(e) \cap_\Re \Re(d) = \phi) 
                    )
            ) \\ &\vee \\
            &((\et{e}{sc} \ \wedge \ \et{d}{uo}) \ \wedge \ 
                    (
                        (\event{e}{W} \ \wedge \ (\Re(e) \cap_\Re \Re(d) = \phi)) 
                    )
            ) \\ &\vee \\
            &((\et{e}{uo} \ \wedge \ \et{d}{sc}) \ \wedge \ 
                    (
                        (\event{d}{R} \ \wedge \ (\Re(e) \cap_\Re \Re(d) = \phi)) 
                    )
            )
            )
        \end{align*}

        \critic{purple}{Use the latter for the purpose at the end of the proof for reordering, to emphasize how we approached each case}

         
    \end{definition}

    \input{InstructionReordering/ValidReorderingProof/theorem.tex}

    \input{InstructionReordering/ValidReorderingProof/proof.tex}

    \input{InstructionReordering/ValidReorderingProof/corollary.tex}

    \input{InstructionReordering/counter_examples.tex}

    \input{InstructionReordering/generalization.tex}
\subsection{}

    

    
    
    
    
    