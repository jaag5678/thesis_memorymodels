\subsection{From Candidates to Program}

    To investigate the validity of reordering at the program level, we first, in terms of candidates, address code motion. The following two corollaries cover them: 
    \begin{corollary}
        Consider a Candidate C of a program and its Candidate Executions which are valid. Consider a set of events $k_{i \in[1,n]}$ such that $\reln{k_i}{ao}{k_{i+1}} \wedge \cons{k_i}{k_{i+1}}$.
        Consider an event $e$ such that 
        \begin{align}
            \cons{e}{k_1} \ \wedge \ \reln{e}{ao}{k_1}  
        \end{align}
        Consider another candidate $C'$ with the only differnence from $C$ being $\cons{e}{k_n} \ \wedge \ \reln{k_n}{ao}{e}$.
        Then the set of observable behaviors of $C'$ is a subset of that of $C$ if 
        \begin{align}
            \forall i \in [1,n] \ . \ Reord(e,k_i)
        \end{align} 
    \end{corollary}

    \begin{proof}
        Apply theorem of reordering successively, and by transititvity of subset relations, the corollary holds.
    \end{proof}

    \begin{corollary}
        Consider a Candidate C of a program and its Candidate Executions which are valid. Consider a set of events $k_{i \in[1,n]}$ such that $\reln{k_i}{ao}{k_{i+1}} \wedge \cons{k_i}{k_{i+1}}$.
        Consider an event $d$ such that 
        \begin{align}
            \cons{d}{k_n} \ \wedge \ \reln{k_n}{ao}{d}  
        \end{align}
        Consider another candidate $C'$ with the only differnence from $C$ being $\cons{d}{k_1} \ \wedge \ \reln{d}{ao}{k_1}$.
        Then the set of observable behaviors of $C'$ is a subset of that of $C$ if 
        \begin{align}
            \forall i \in [1,n] \ . \ Reord(k_i,d)
        \end{align} 
    \end{corollary}

    \begin{proof}
        Apply theorem of reordering successively, and by transititvity of subset relations, the corollary holds.
    \end{proof}

    \critic{blue}{The above corollaries defined is the general form of reordering, which also defines code motion. It is interesting to note that we first noted reordering as reversing agent order, but we never considered it as strictly as we should have. Perhaps make the corollary for non-consecutive reordering of two events more precise.}

    We first consider programs with conditionals. The following property holds for any candidates of programs having conditional branching. 

    \begin{property}{Candidates of Programs with Conditionals (2-branch)}
        Let $B1,B2$ be two sets of events based on each branch of a conditional in a program $P$. Let $C$ be any Candidate of $P$, Consider $b1,b2$ to be representative of any event in $B1,B2$ respectively. Then:
        \begin{align*}
            \nexists C \in P \ \text{s.t.} \ b1 \in C \ \wedge \ b2 \in C 
        \end{align*}
        There cannot exist any candidate of the program such that events from both sets can be part of it. 
    \end{property}

    \begin{property}{Candidates of Programs with Conditionals (1-branch)}
        Let $B1$ be two sets of events based on each branch of a conditional in a program $P$. Let $C$ be any Candidate of $P$, Consider $b1$ to be representative of any event in $B1$. Then:
        \begin{align*}
            \exists C \in P \ \text{s.t.} \ b1 \notin C  
        \end{align*}
        There exists a candidate of the program such that events from the branch cannot be part of it. 
    \end{property}

    \critic{blue}{While the property for 1 branch may not always hold (it can be the case that the branch is always taken in any execution) we are defining it for any program.}

    \begin{proof}
        Based on an exeuction of the program, the conditional will either be satisfied or not, but never both. Hence proved both properties. 
        \critic{blue}{Do we need an elaborate proof of this? As this is direct from existing literature on sequential programs.}
    \end{proof}

    Perhaps we need a general corollary for program level 
    \begin{corollary}{Reordering under Program with Conditionals}
        Consider a program $P$ and its candidates $C_1, C_2, ... , C_n$ in which events $e$ and $d$ present in all of them with $\reln{e}{ao}{d}$. Consider the set of corresponding candidates $C'_1, C'_2, ... , C'_n$ after reordering $e$ and $d$ and its corresponding program $P'$. Then the set of observable behaviors of $P'$ is a subset of that of $P$ if:
        \begin{align*}
            Reord(e,d) \ \wedge \ 
            ( \forall C_{i \in [1,n]}, \forall k \in C_i \ \text{s.t.} \ \reln{e}{ao}{k} \wedge \reln{k}{ao}{d}, \    
            Reord(e,k) \wedge Reord(k,d) )
        \end{align*}
        \critic{red}{The above condition can be simplified as we already have corollary to show reordering of non-consecutive events}
        \critic{blue}{No Candidate of $P$ exists such that only one of $e$ or $d$ exists in them. }
        \begin{align*}
            \nexists C \in P \ s.t. \ 
                (e \in C \ \wedge \ d \notin C) \ \vee \ 
                (e \notin C \ \wedge \ d \in C) 
        \end{align*}
    \end{corollary}

    \begin{proof}
        The proof would go as follows:
        \begin{itemize}
            \item By property of conditionals, there could be a candidate with $e$ existing but $d$ not. This would mean that $d$ is a part of conditional brnaching. Meaning if $d$ is event in one branch and $k$ is in the other branch, then Property of conditionals must hold for any candidate. 
            \item After reordering the property for candidates based on original program does not hold, thus having a candidate where $d$ and $k$ exist. 
            \item If $d$ is a write, then a new reads from relation can exist, thus introducing a new observable behavior.
            \item If $d$ is a read, then too a new reads-from relation can exist. 
            \item Note that here, we are talking in terms of candidates, meaning if a reads-from relation cannot exist, it is not due to the Consistency rules, but that such an event does not exist. This is different from restricting behaviors, rather its introducing new behaviors. 
            \item Perhaps this should be mentioned in the proofs where only one candidate is considered too.  
        \end{itemize}
    \end{proof}

    \critic{blue}{It has come to my notice that in general reordering may not be fine, if we end up removing something outside a conditional. To show this I have a simple counter example. However, the only way to show this, is to say that there is some candidate which suddenly has an agent order relation between two events which were not supposed to have any relation to them. Simply put, we can say that there is a candidate execution of the reordered program, where both the events exist, where as there isn't any candidate of the original program where such a thing can happen.}
