\subsection{From Candidates to Program}

    Insights:
    \begin{itemize}
        \item At the program level, what is done in general is code motion. 
        \item We can classify differnt cases of code motion. 
        \item The two parts would be that of conditionals and that of loops.
        \item We still did not define general reordering, but we viewed it in terms of agent order to be general enough. 
    \end{itemize}

    General Corollary defining code motion in a Candidate, not a program. 
    \begin{corollary}
        Consider a Candidate C of a program and its Candidate Executions which are valid. Consider a set of events ${k_1, k_2, ... k_n}$ such that 
        \begin{align}
            \forall i \in [1,n-1] \ . \ \reln{k_i}{ao}{k_{i+1}} \wedge \cons{k_i}{k_{i+1}} 
        \end{align}
        Consider an event $e$ such that 
        \begin{align}
            \cons{e}{k_1} \ \wedge \ \reln{e}{ao}{d}  
        \end{align}
        Consider another candidate $C'$ with the only differnence from $C$ being that
        \begin{align}
            \cons{e}{k_n} \ \wedge \ \reln{k_n}{ao}{e}
        \end{align}
        Then the set of observable behaviors of $C'$ is a subset of that of $C$ only if 
        \begin{align}
            \forall i \in [1,n] \ . \ Reord(e,k_i)
        \end{align} 
    \end{corollary}

    \begin{proof}
        Apply theorem of reordering successively, and by transititvity of subset relations, the corollary holds.
    \end{proof}

    \critic{blue}{The above corollary we defined is the most general form of reordering, which also defines code motion. It is interesting to note that we first noted reordering as reversing agent order, but we never considered it as strictly as we should have.}

    \critic{red}{Make the corollary more precise, it can be simplified greatly.}
    
    Preliminaries needed for conditionals:
    \begin{itemize}
        \item One conditional results in two possible candidates. Describe formally that the two candidates are distinct, in that there are some events that aren't present in each of them, but are present in the other. 
        \item There are two types of conditionals; need to have two defintions for conditionals then. 
    \end{itemize}

    Perhaps we need a general corollary for program level 
    \begin{corollary}{Reordering under Program with Conditionals}
        Consider a program $P$ and its candidates $C_1, C_2, ... , C_n$ in which events $e$ and $d$ present in all of them with $\reln{e}{ao}{d}$. Consider the set of corresponding candidates $C'_1, C'_2, ... , C'_n$ after reordering $e$ and $d$ and its corresponding program $P'$. Then the set of observable behaviors of $P'$ is a subset of that of $P$ if the following conditions hold:
        \begin{align*}
            Reord(e,d) \ \wedge \ \\ 
            \forall C_{i \in [1,n]} \ , \ \forall k \in C_i \ \text{s.t.} \ \reln{e}{ao}{k} \wedge \reln{k}{ao}{d} \\ 
            Reord(e,k) \wedge Reord(k,d) 
        \end{align*}
        \critic{red}{The above condition can be simplified as we already have corollary to show reordering of non-consecutive events}
        \critic{blue}{No Candidate of $P$ exists such that only one of $e$ or $d$ exists in them. }
        \begin{align*}
            \nexists C \in P \ s.t. \ 
                (e \in C \ \wedge \ d \notin C) \ \vee \ 
                (e \notin C \ \wedge \ d \in C) 
        \end{align*}
    \end{corollary}

    \begin{proof}
        The proof would go as follows:
        \begin{itemize}
            \item By property of conditionals, there could be a candidate with $e$ existing but $d$ not. This would mean that $d$ is a part of conditional brnaching.
            \item Reordering would then result in removing certain agent order relations with $e$ and adding the same with $d$.
            \item Removal occurs because after reordering, $P'$ will have candidates with $d$ existing but not $e$. 
            \item Adding occurs in the same fashion.
            \item Removal in this case may result in new observable behaviors with events outside the same agent
            \item Adding may also introduce new observable behaviors with events outside the same agent. 
            \item The new observable behaviors can occur due to the other conditional branch having some sc events that syncronize with other threads.
            \item Maybe finding SC events in the other branch may not be so difficult to do. But perhaps if it is difficult, then reordering should not be done. 
            \item Perhaps we could say that those events with whome $d$ has now relations, if it is the case that it has a new relation with some $k$ thats of type $sc$ (perhaps we can narrow it down to a read / write), then we shouldnt be allowed to do reordering. 
        \end{itemize}
    \end{proof}

    \critic{blue}{It has come to my notice that in general reordering may not be fine, if we end up removing something outside a conditional. To show this I have a simple counter example. However, the only way to show this, is to say that there is some candidate which suddenly has an agent order relation between two events which were not supposed to have any relation to them. Simply put, we can say that there is a candidate execution of the reordered program, where both the events exist, where as there isn't any candidate of the original program where such a thing can happen.}
